# -*- coding: utf-8 -*-
"""pla.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hC3gLstlaSNI3WYjWwH88QB-tE2amV9U
"""

import numpy as np
import secrets
import torch
from tqdm import tqdm
import matplotlib.pyplot as plt

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

N = 200
D = 47205
TIMES = 1000

def load_libsvm_data(file_path, num_lines=200, num_features=47205):
    data = []
    labels = []

    with open(file_path, 'r') as f:
        for i in range(N):
          line = (f.readline()).split()

          y = int(line[0])
          x = torch.zeros(num_features)

          for feature in line[1:]:
            index, value = map(float, feature.split(":"))
            x[int(index) - 1] = value  # feature index start from 1

          data.append(x)
          labels.append(y)

    return torch.stack(data), torch.tensor(labels)


def pla(data, labels):
    x_0 = torch.tensor([1], device = device)  # x[0] = 1
    w = torch.zeros(D + 1, device=device)     # w_0 = [0, 0, ... 0]

    consecutive_correct = 0
    target_correct = 5 * N
    updates = 0

    labels_tensor = torch.tensor(labels, dtype=torch.float64)

    while consecutive_correct < target_correct:
        i = secrets.randbelow(N)              # random seed
        x_n = data[i]
        x_n = torch.cat((x_0, data[i]))
        y_n = labels_tensor[i]

        if torch.sign(torch.dot(w, x_n)) != y_n:
            consecutive_correct = 0
            updates += 1
            w += y_n * x_n
        else:
            consecutive_correct += 1

    return w, updates


# def test_pla(data, labels, w):
#     labels_tensor = torch.tensor(labels, dtype=torch.float64)

#     for _ in range(5*N):
#         i = secrets.randbelow(N)
#         x_n = data[i]
#         y_n = labels_tensor[i]

#         if torch.sign(torch.dot(w, x_n)) != y_n:
#             return False

#     return True

def experiments(data, labels):
    updates_list = []

    for _ in tqdm(range(TIMES), desc="Running PLA experiments"):
        _, updates = pla(data, labels)
        updates_list.append(updates)

    # histogram of the distribution of the number of updates
    plt.figure(figsize=(10, 6))
    plt.hist(updates_list, bins=30, color='blue', alpha=0.7)
    plt.title('Distribution of Updates in PLA')
    plt.xlabel('Number of Updates')
    plt.ylabel('Frequency')
    plt.grid(True)
    plt.show()

    print(f"Median of updates: {np.median(updates_list)}")
    print(f"Mean of updates: {np.mean(updates_list)}")

if __name__ == '__main__':
    data, labels = load_libsvm_data('./rcv1_train.binary')
    data, labels = data.to(device), labels.to(device)

    experiments(data, labels)